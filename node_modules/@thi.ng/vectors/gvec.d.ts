import type { NumericArray } from "@thi.ng/api";
import type { IVector } from "./api.js";
/**
 * Wrapper for strided, arbitrary length vectors.
 *
 * @remarks
 * Wraps given buffer in ES6 `Proxy` with custom property getters/setters and
 * implements the following interfaces:
 *
 * - `Iterable` (ES6)
 * - [`ICopy`](https://docs.thi.ng/umbrella/api/interfaces/ICopy.html)
 * - [`IEmpty`](https://docs.thi.ng/umbrella/api/interfaces/IEmpty.html)
 * - [`IEqualsDelta`](https://docs.thi.ng/umbrella/api/interfaces/IEqualsDelta.html)
 * - {@link IVector}
 * - `Object.toString()`
 *
 * Read/write access for the following properties:
 *
 * - array indices in the [0 .. `size`) interval
 * - `offset` - start index
 * - `stride` - component stride
 * - `buf` - backing buffer (readonly)
 * - `length` - vector size
 *
 * Array index access uses bounds checking against the [0 .. `size`) interval,
 * but, for performance reasons, **not** against the actual wrapped buffer.
 *
 * Note: ES6 proxies are ~10x slower than standard array accesses. If several
 * computations are to be performed on such vectors it will be much more
 * efficient to first copy them to compact arrays and then copy result back if
 * needed.
 *
 * @example
 * ```ts
 * import { gvec, eqDelta } from "@thi.ng/vectors";
 *
 * // 3D vector w/ component stride length of 4
 * a = gvec([1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], 3, 0, 4);
 * a[0] // 1
 * a[1] // 2
 * a[2] // 3
 *
 * a.stride
 * // 4
 *
 * [...a]
 * // [1, 2, 3]
 *
 * a.toString()
 * // "[1,2,3]"
 *
 * add([], a, a)
 * // [2, 4, 6]
 *
 * copy(a)
 * // [1, 2, 3]
 *
 * a.copyView()
 * // Proxy [ [ 1, 0, 2, 0, 3, 0 ], ... }
 *
 * eqDelta(a, [1, 2, 3])
 * // true
 * ```
 *
 * @param buf - backing buffer
 * @param size - vector size / num components
 * @param offset - start index
 * @param stride - component stride
 */
export declare const gvec: (buf: NumericArray, size: number, offset?: number, stride?: number) => IVector<any>;
//# sourceMappingURL=gvec.d.ts.map