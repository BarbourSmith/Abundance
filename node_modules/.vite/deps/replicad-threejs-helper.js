import {
  BufferGeometry,
  EdgesGeometry,
  Float32BufferAttribute
} from "./chunk-OJ65C3UH.js";
import "./chunk-3EJPJMEH.js";

// node_modules/replicad-threejs-helper/dist/es/replicad-threejs-helper.js
function syncGeometries(replicadMeshes, inputGeometries = []) {
  let geometries = inputGeometries;
  if (inputGeometries.length !== replicadMeshes.length) {
    inputGeometries.forEach(({ lines, faces }) => {
      faces.dispose();
      lines.dispose();
    });
    geometries = replicadMeshes.map(({ name }) => ({
      name,
      faces: new BufferGeometry(),
      lines: new BufferGeometry()
    }));
  }
  geometries.forEach(({ faces, lines }, i) => {
    syncFaces(faces, replicadMeshes[i].faces);
    const edges = replicadMeshes[i].edges;
    edges !== void 0 ? syncLines(lines, edges) : syncLinesFromFaces(lines, faces);
  });
  return geometries;
}
function syncFaces(faces, replicadMesh, highlight) {
  faces.clearGroups();
  delete faces.userData.faceGroups;
  faces.setIndex(replicadMesh.triangles);
  faces.setAttribute("position", new Float32BufferAttribute(replicadMesh.vertices, 3));
  if (replicadMesh.faceGroups) {
    let shouldHighlight = /* @__PURE__ */ new Set();
    if (highlight) {
      shouldHighlight = new Set(highlight);
    }
    faces.userData.faceGroups = replicadMesh.faceGroups;
    replicadMesh.faceGroups.forEach(({ start, count, faceId }) => {
      faces.addGroup(start, count, shouldHighlight.has(faceId) ? 1 : 0);
    });
  } else {
    faces.addGroup(0, replicadMesh.triangles.length, 0);
  }
  if (replicadMesh.normals && replicadMesh.normals.length) {
    faces.setAttribute("normal", new Float32BufferAttribute(replicadMesh.normals, 3));
  } else {
    faces.computeVertexNormals();
  }
  faces.computeBoundingBox();
}
function syncLines(lines, edges, highlight) {
  lines.clearGroups();
  delete lines.userData.edgeGroups;
  lines.setAttribute("position", new Float32BufferAttribute(edges.lines, 3));
  if (!edges)
    return;
  if (edges.edgeGroups) {
    let shouldHighlight = /* @__PURE__ */ new Set();
    if (highlight) {
      shouldHighlight = new Set(highlight);
    }
    lines.userData.edgeGroups = edges.edgeGroups;
    edges.edgeGroups.forEach(({ start, count, edgeId }) => {
      lines.addGroup(start, count, shouldHighlight.has(edgeId) ? 1 : 0);
    });
  } else {
    lines.addGroup(0, edges.lines.length / 3, 0);
  }
}
function syncLinesFromFaces(lines, faces) {
  lines.clearGroups();
  delete lines.userData.edgeGroups;
  lines.copy(new EdgesGeometry(faces, 2));
}
var groupFinder = (faceIndex) => ({ start, count }) => {
  return faceIndex >= start && faceIndex < start + count;
};
function toggleHighlight(groupIndex, geometry) {
  const group = geometry.groups.find(groupFinder(groupIndex));
  if (group) {
    group.materialIndex = group.materialIndex ? 0 : 1;
    geometry.groupsNeedUpdate = true;
  }
}
function clearHighlights(geometry) {
  geometry.groups.forEach((g) => {
    if (g.materialIndex !== 0) {
      geometry.groupsNeedUpdate = true;
      g.materialIndex = 0;
    }
  });
}
function highlightInGeometry(elements, geometry) {
  const groupIndices = new Set(elements);
  geometry.groups.forEach((group, groupIndex) => {
    const shouldHighlight = groupIndices.has(groupIndex);
    const isHighlighted = group.materialIndex === 1;
    if (shouldHighlight === isHighlighted)
      return;
    group.materialIndex = shouldHighlight ? 1 : 0;
    geometry.groupsNeedUpdate = true;
  });
}
function getFaceId(triangleIndex, geometry) {
  const { faceId } = geometry.userData.faceGroups.find(groupFinder(triangleIndex * 3)) || {};
  return faceId;
}
function getEdgeId(lineIndex, geometry) {
  const { edgeId } = geometry.userData.edgeGroups.find(groupFinder(lineIndex)) || {};
  return edgeId;
}
function getFaceIndex(triangleIndex, geometry) {
  return geometry.groups.findIndex(groupFinder(triangleIndex * 3));
}
function getEdgeIndex(lineIndex, geometry) {
  return geometry.groups.findIndex(groupFinder(lineIndex));
}
export {
  clearHighlights,
  getEdgeId,
  getEdgeIndex,
  getFaceId,
  getFaceIndex,
  highlightInGeometry,
  syncFaces,
  syncGeometries,
  syncLines,
  syncLinesFromFaces,
  toggleHighlight
};
//# sourceMappingURL=replicad-threejs-helper.js.map
