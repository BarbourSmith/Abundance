{
  "version": 3,
  "sources": ["../../replicad-threejs-helper/lib/replicad-threejs-helper.ts"],
  "sourcesContent": ["import { BufferGeometry, Float32BufferAttribute, EdgesGeometry } from \"three\";\n\nexport interface ReplicadMeshedFaces {\n  vertices: number[];\n  triangles: number[];\n  normals?: number[];\n  faceGroups?: { start: number; count: number; faceId: number }[];\n}\n\nexport interface ReplicadMeshedEdges {\n  lines: number[];\n  edgeGroups?: { start: number; count: number; edgeId: number }[];\n}\n\nexport interface ReplicadMesh {\n  name?: string;\n  faces: ReplicadMeshedFaces;\n  edges?: ReplicadMeshedEdges;\n}\n\nexport interface ThreeGeometry {\n  faces: BufferGeometry;\n  lines: BufferGeometry;\n}\n\n/**\n * Create or update a set of threejs geometries from some meshed edges and\n * faces from replicad\n */\nexport function syncGeometries(\n  replicadMeshes: ReplicadMesh[],\n  inputGeometries: ThreeGeometry[] = []\n): ThreeGeometry[] {\n  let geometries = inputGeometries;\n  if (inputGeometries.length !== replicadMeshes.length) {\n    inputGeometries.forEach(({ lines, faces }) => {\n      faces.dispose();\n      lines.dispose();\n    });\n    geometries = replicadMeshes.map(({ name }) => ({\n      name,\n      faces: new BufferGeometry(),\n      lines: new BufferGeometry(),\n    }));\n  }\n\n  geometries.forEach(({ faces, lines }, i) => {\n    syncFaces(faces, replicadMeshes[i].faces);\n    const edges = replicadMeshes[i].edges;\n    edges !== undefined\n      ? syncLines(lines, edges)\n      : syncLinesFromFaces(lines, faces);\n  });\n\n  return geometries;\n}\n\n/**\n * Update a threejs BufferGeometry from some meshed faces from replicad.\n */\nexport function syncFaces(\n  faces: BufferGeometry,\n  replicadMesh: ReplicadMeshedFaces,\n  highlight?: number[]\n): void {\n  faces.clearGroups();\n  delete faces.userData.faceGroups;\n  faces.setIndex(replicadMesh.triangles);\n  faces.setAttribute(\n    \"position\",\n    new Float32BufferAttribute(replicadMesh.vertices, 3)\n  );\n\n  // If you want to change the way colors are applied to different faces you\n  // can change the following code. The group id will correspond to the index\n  // of the materials you link to the mesh of this geometry\n  //\n  // This only works with two materials, the standard one, and the highlight\n  // one.\n  if (replicadMesh.faceGroups) {\n    let shouldHighlight = new Set();\n    if (highlight) {\n      shouldHighlight = new Set(highlight);\n    }\n    faces.userData.faceGroups = replicadMesh.faceGroups;\n    replicadMesh.faceGroups.forEach(({ start, count, faceId }) => {\n      faces.addGroup(start, count, shouldHighlight.has(faceId) ? 1 : 0);\n    });\n  } else {\n    faces.addGroup(0, replicadMesh.triangles.length, 0);\n  }\n\n  if (replicadMesh.normals && replicadMesh.normals.length) {\n    faces.setAttribute(\n      \"normal\",\n      new Float32BufferAttribute(replicadMesh.normals, 3)\n    );\n  } else {\n    faces.computeVertexNormals();\n  }\n\n  faces.computeBoundingBox();\n}\n\n/**\n * Update a threejs BufferGeometry from meshed edges from replicad.\n */\nexport function syncLines(\n  lines: BufferGeometry,\n  edges: ReplicadMeshedEdges,\n  highlight?: number[]\n): void {\n  lines.clearGroups();\n  delete lines.userData.edgeGroups;\n\n  lines.setAttribute(\"position\", new Float32BufferAttribute(edges.lines, 3));\n\n  if (!edges) return;\n  if (edges.edgeGroups) {\n    let shouldHighlight = new Set();\n    if (highlight) {\n      shouldHighlight = new Set(highlight);\n    }\n    lines.userData.edgeGroups = edges.edgeGroups;\n    edges.edgeGroups.forEach(({ start, count, edgeId }) => {\n      lines.addGroup(start, count, shouldHighlight.has(edgeId) ? 1 : 0);\n    });\n  } else {\n    lines.addGroup(0, edges.lines.length / 3, 0);\n  }\n}\n\n/**\n * Update a threejs BufferGeometry from the faces buffer geometry\n * Uses threejs EdgesGeometry to guess the relevant edges\n */\nexport function syncLinesFromFaces(\n  lines: BufferGeometry,\n  faces: BufferGeometry\n) {\n  lines.clearGroups();\n  delete lines.userData.edgeGroups;\n\n  lines.copy(new EdgesGeometry(faces, 2));\n}\n\n// Finds the group a specific element is part of\n// This makes the link between the triangles / lines that respectively build\n// faces / edges\nconst groupFinder =\n  (faceIndex: number) =>\n  ({ start, count }: { start: number; count: number }) => {\n    return faceIndex >= start && faceIndex < start + count;\n  };\n\n/**\n * Changes the material used to represent a certain face or edge by the index\n * of its group\n */\nexport function toggleHighlight(\n  groupIndex: number,\n  geometry: BufferGeometry\n): void {\n  const group = geometry.groups.find(groupFinder(groupIndex));\n  if (group) {\n    group.materialIndex = group.materialIndex ? 0 : 1;\n    // @ts-expect-error types not up to date\n    geometry.groupsNeedUpdate = true;\n  }\n}\n\n/**\n * Set all the materials used to the default one.\n */\nexport function clearHighlights(geometry: BufferGeometry): void {\n  geometry.groups.forEach((g) => {\n    if (g.materialIndex !== 0) {\n      // @ts-expect-error types not up to date\n      geometry.groupsNeedUpdate = true;\n      g.materialIndex = 0;\n    }\n  });\n}\n\n/**\n * Make sure that the elements highlighted in the geometry are only the ones in\n * the elements param.\n */\nexport function highlightInGeometry(\n  elements: number[],\n  geometry: ThreeGeometry\n): void {\n  const groupIndices = new Set(elements);\n\n  // @ts-expect-error types not up to date\n  geometry.groups.forEach(\n    (group: { materialIndex: number }, groupIndex: number) => {\n      const shouldHighlight = groupIndices.has(groupIndex);\n      const isHighlighted = group.materialIndex === 1;\n      if (shouldHighlight === isHighlighted) return;\n\n      group.materialIndex = shouldHighlight ? 1 : 0;\n\n      // @ts-expect-error types not up to date\n      geometry.groupsNeedUpdate = true;\n    }\n  );\n}\n\nexport function getFaceId(\n  triangleIndex: number,\n  geometry: BufferGeometry\n): number {\n  const { faceId } =\n    geometry.userData.faceGroups.find(groupFinder(triangleIndex * 3)) || {};\n  return faceId;\n}\n\nexport function getEdgeId(lineIndex: number, geometry: BufferGeometry): number {\n  const { edgeId } =\n    geometry.userData.edgeGroups.find(groupFinder(lineIndex)) || {};\n  return edgeId;\n}\n\nexport function getFaceIndex(\n  triangleIndex: number,\n  geometry: BufferGeometry\n): number {\n  return geometry.groups.findIndex(groupFinder(triangleIndex * 3));\n}\n\nexport function getEdgeIndex(\n  lineIndex: number,\n  geometry: BufferGeometry\n): number {\n  return geometry.groups.findIndex(groupFinder(lineIndex));\n}\n"],
  "mappings": "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",
  "names": []
}
