{
  "version": 3,
  "sources": ["../../replicad-shrink-wrap/dist/studio/replicad-shrink-wrap.js"],
  "sourcesContent": ["const { Drawing, Blueprint, draw } = replicad;\n\nlet EPS = 1e-6;\n\nconst atan2 = Math.atan2;\nconst grahamScan2 = (pts, eps = EPS) => {\n  const num = pts.length;\n  if (num <= 3) return pts.slice();\n  let h = 1;\n  let i;\n  let p;\n  let q;\n  let r;\n  let rx;\n  let ry;\n  const min = findMin(pts);\n  [rx, ry] = pts[min];\n  const sorted = [];\n  for (i = 0; i < num; i++) {\n    p = pts[i];\n    sorted[i] = { p, t: atan2(p[1] - ry, p[0] - rx) };\n  }\n  sorted.sort((a, b) => a.t !== b.t ? a.t - b.t : a.p[0] - b.p[0]);\n  const hull = [sorted[0].p];\n  for (i = 1; i < num; i++) {\n    p = hull[h - 2];\n    q = hull[h - 1];\n    r = sorted[i].p;\n    rx = r[0];\n    ry = r[1];\n    while (h > 1 && notCCW(p[0], p[1], q[0], q[1], rx, ry, eps) || h === 1 && q[0] === rx && q[1] === ry) {\n      h--;\n      q = p;\n      p = hull[h - 2];\n    }\n    hull[h++] = r;\n  }\n  hull.length = h;\n  return hull;\n};\nconst notCCW = (ax, ay, bx, by, cx, cy, eps) => (by - ay) * (cx - ax) >= (bx - ax) * (cy - ay) - eps;\nconst findMin = (pts) => {\n  let n = pts.length - 1;\n  let minID = n;\n  let [minX, minY] = pts[n];\n  let p, y;\n  for (; n-- > 0; ) {\n    p = pts[n];\n    y = p[1];\n    if (y < minY || y === minY && p[0] < minX) {\n      minX = p[0];\n      minY = y;\n      minID = n;\n    }\n  }\n  return minID;\n};\n\n// helpers\nfunction makeSegmentCurve(p1, p2) {\n  const s = draw(p1).lineTo(p2);\n  return s.pendingCurves[0];\n}\nconst range = (size) => Array.from({ length: size }, (_, i) => i);\nconst isSamePoint = ([x0, y0], [x1, y1], precision = 1e-6) => {\n  return Math.abs(x0 - x1) <= precision && Math.abs(y0 - y1) <= precision;\n};\n\nconst zipWithNext = (arr) =>\n  arr\n    .slice(0, -1)\n    .map((_, i) => [arr[i], arr[i + 1]])\n    .concat([[arr.at(-1), arr[0]]]);\n\n// This function takes a drawing and a number of points per curve and returns\n// an array of points with some meta data attached to them.\n//\n// The meta data can be an array of two objects if the point is between two curves\nconst asPoints = (drawing, pointPerCurve) => {\n  const inner = drawing.innerShape;\n  const blueprints = inner.blueprints || [inner];\n\n  const firstPointIndex = 0;\n  const lastPointIndex = pointPerCurve - 1;\n\n  let blueprintCurveIndex = 0;\n\n  return blueprints.flatMap((blueprint) => {\n    const curves = blueprint.curves;\n\n    let points = curves.flatMap((curve, curveIndex) => {\n      const firstParam = curve.firstParameter;\n      const lastParam = curve.lastParameter;\n\n      const paramRange = lastParam - firstParam;\n\n      const lastPoint = curve.value(lastParam);\n      const nextCurveIndex = (curveIndex + 1) % curves.length;\n      const nextCurve = curves[nextCurveIndex];\n\n      lastPoint.meta = [\n        {\n          curve,\n          param: lastParam,\n          curveIndex: curveIndex + blueprintCurveIndex,\n          pointIndex: lastPointIndex,\n        },\n        {\n          curve: nextCurve,\n          param: nextCurve.firstParameter,\n          curveIndex: nextCurveIndex + blueprintCurveIndex,\n          pointIndex: firstPointIndex,\n        },\n      ];\n\n      // This normalizes the parameter to the range [0, 1]\n      const adaptParam = (p) => {\n        return firstParam + p * paramRange;\n      };\n\n      return [\n        lastPoint,\n        // The range is two smaller because we already have the first and last point\n        ...range(pointPerCurve - 2).map((i) => {\n          const param = adaptParam((i + 1) / pointPerCurve);\n          const value = curve.value(param);\n          value.meta = {\n            curve,\n            param,\n            curveIndex: curveIndex + blueprintCurveIndex,\n            // We start at 0\n            pointIndex: i + 1,\n          };\n          return value;\n        }),\n      ];\n    });\n    blueprintCurveIndex += curves.length;\n    return points;\n  });\n};\n\nfunction shrinkWrap(drawing, nPoints = 100) {\n  const points = asPoints(drawing, nPoints);\n  let convexHull = grahamScan2(points);\n  convexHull = convexHull.flatMap((p, i) => {\n    const meta = p.meta;\n\n    // For points that are not between two curves\n    if (!Array.isArray(meta)) {\n      return [p];\n    }\n\n    // We want to split the point as two points in two curves\n    const [first, second] = meta.map((m) => {\n      const p2 = [p[0], p[1]];\n      p2.meta = m;\n      return p2;\n    });\n\n    // depending on the order of the convex hull we need to swap the points\n    const firstCurveIndex = first.meta.curveIndex;\n    const secondCurveIndex = second.meta.curveIndex;\n    const nextCurveIndex =\n      convexHull[(i + 1) % convexHull.length].meta.curveIndex;\n    const previousCurveIndex =\n      convexHull[(i - 1 + convexHull.length) % convexHull.length].meta\n        .curveIndex;\n\n    if (\n      firstCurveIndex === nextCurveIndex &&\n      secondCurveIndex === previousCurveIndex\n    ) {\n      return [second, first];\n    }\n    return [first, second];\n  });\n\n  // We only want to keep the points that are between two curves\n  let curveChanges = zipWithNext(convexHull)\n    .filter(([p1, p2]) => {\n      if (p1.meta.curveIndex === p2.meta.curveIndex) {\n        if (p1.meta.curve.geomType === \"LINE\") {\n          return false;\n        }\n        return Math.abs(p2.meta.pointIndex - p1.meta.pointIndex) !== 1;\n      }\n\n      return true;\n    })\n    .flat();\n\n  curveChanges = curveChanges.filter((current, i) => {\n    // We remove duplicates (that appear because of the zip with next)\n    const previous = curveChanges[(i + 1) % curveChanges.length];\n    const sameCurve = current.meta.curveIndex === previous.meta.curveIndex;\n    const samePoint = current.meta.pointIndex === previous.meta.pointIndex;\n    return !sameCurve || !samePoint;\n  });\n\n  const shape = zipWithNext(curveChanges)\n    .filter(([p1, p2]) => !isSamePoint(p1, p2))\n    .map(([p1, p2]) => {\n      // This is where we pick the curves we need\n\n      if (p1.meta.curveIndex === p2.meta.curveIndex) {\n        // Were we just take the base curve\n        if (p1.meta.pointIndex === 0 && p2.meta.pointIndex === nPoints - 1) {\n          return p1.meta.curve;\n        }\n\n        // The curve is full, but we need to reverse it\n        if (p1.meta.pointIndex === nPoints - 1 && p2.meta.pointIndex === 0) {\n          let c = p1.meta.curve.clone();\n          c.reverse();\n          return c;\n        }\n\n        // We need to split the curve somewhere\n        const splitAt = [p1, p2]\n          .filter(\n            (p) => p.meta.pointIndex !== 0 && p.meta.pointIndex !== nPoints - 1\n          )\n          .map((p) => p.meta.param);\n\n        const segments = p1.meta.curve.splitAt(splitAt);\n\n        // We have three possible cases:\n        // 1. One split and we keep the first part\n        // 2. One split and we keep the second part\n        // 3. Two splits and we keep the middle (second) part\n        let segment = segments[0];\n        if (p1.meta.pointIndex !== 0 && p2.meta.pointIndex !== 0) {\n          segment = segments[1];\n        }\n\n        if (p1.meta.pointIndex > p2.meta.pointIndex) {\n          segment.reverse();\n        }\n\n        return segment;\n      }\n\n      return makeSegmentCurve(p1, p2);\n    });\n\n  return new Drawing(new Blueprint(shape));\n}\n\nexport { shrinkWrap as default };\n"],
  "mappings": "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",
  "names": []
}
