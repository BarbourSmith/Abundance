// node_modules/replicad-shrink-wrap/dist/studio/replicad-shrink-wrap.js
var { Drawing, Blueprint, draw } = replicad;
var EPS = 1e-6;
var atan2 = Math.atan2;
var grahamScan2 = (pts, eps = EPS) => {
  const num = pts.length;
  if (num <= 3)
    return pts.slice();
  let h = 1;
  let i;
  let p;
  let q;
  let r;
  let rx;
  let ry;
  const min = findMin(pts);
  [rx, ry] = pts[min];
  const sorted = [];
  for (i = 0; i < num; i++) {
    p = pts[i];
    sorted[i] = { p, t: atan2(p[1] - ry, p[0] - rx) };
  }
  sorted.sort((a, b) => a.t !== b.t ? a.t - b.t : a.p[0] - b.p[0]);
  const hull = [sorted[0].p];
  for (i = 1; i < num; i++) {
    p = hull[h - 2];
    q = hull[h - 1];
    r = sorted[i].p;
    rx = r[0];
    ry = r[1];
    while (h > 1 && notCCW(p[0], p[1], q[0], q[1], rx, ry, eps) || h === 1 && q[0] === rx && q[1] === ry) {
      h--;
      q = p;
      p = hull[h - 2];
    }
    hull[h++] = r;
  }
  hull.length = h;
  return hull;
};
var notCCW = (ax, ay, bx, by, cx, cy, eps) => (by - ay) * (cx - ax) >= (bx - ax) * (cy - ay) - eps;
var findMin = (pts) => {
  let n = pts.length - 1;
  let minID = n;
  let [minX, minY] = pts[n];
  let p, y;
  for (; n-- > 0; ) {
    p = pts[n];
    y = p[1];
    if (y < minY || y === minY && p[0] < minX) {
      minX = p[0];
      minY = y;
      minID = n;
    }
  }
  return minID;
};
function makeSegmentCurve(p1, p2) {
  const s = draw(p1).lineTo(p2);
  return s.pendingCurves[0];
}
var range = (size) => Array.from({ length: size }, (_, i) => i);
var isSamePoint = ([x0, y0], [x1, y1], precision = 1e-6) => {
  return Math.abs(x0 - x1) <= precision && Math.abs(y0 - y1) <= precision;
};
var zipWithNext = (arr) => arr.slice(0, -1).map((_, i) => [arr[i], arr[i + 1]]).concat([[arr.at(-1), arr[0]]]);
var asPoints = (drawing, pointPerCurve) => {
  const inner = drawing.innerShape;
  const blueprints = inner.blueprints || [inner];
  const firstPointIndex = 0;
  const lastPointIndex = pointPerCurve - 1;
  let blueprintCurveIndex = 0;
  return blueprints.flatMap((blueprint) => {
    const curves = blueprint.curves;
    let points = curves.flatMap((curve, curveIndex) => {
      const firstParam = curve.firstParameter;
      const lastParam = curve.lastParameter;
      const paramRange = lastParam - firstParam;
      const lastPoint = curve.value(lastParam);
      const nextCurveIndex = (curveIndex + 1) % curves.length;
      const nextCurve = curves[nextCurveIndex];
      lastPoint.meta = [
        {
          curve,
          param: lastParam,
          curveIndex: curveIndex + blueprintCurveIndex,
          pointIndex: lastPointIndex
        },
        {
          curve: nextCurve,
          param: nextCurve.firstParameter,
          curveIndex: nextCurveIndex + blueprintCurveIndex,
          pointIndex: firstPointIndex
        }
      ];
      const adaptParam = (p) => {
        return firstParam + p * paramRange;
      };
      return [
        lastPoint,
        // The range is two smaller because we already have the first and last point
        ...range(pointPerCurve - 2).map((i) => {
          const param = adaptParam((i + 1) / pointPerCurve);
          const value = curve.value(param);
          value.meta = {
            curve,
            param,
            curveIndex: curveIndex + blueprintCurveIndex,
            // We start at 0
            pointIndex: i + 1
          };
          return value;
        })
      ];
    });
    blueprintCurveIndex += curves.length;
    return points;
  });
};
function shrinkWrap(drawing, nPoints = 100) {
  const points = asPoints(drawing, nPoints);
  let convexHull = grahamScan2(points);
  convexHull = convexHull.flatMap((p, i) => {
    const meta = p.meta;
    if (!Array.isArray(meta)) {
      return [p];
    }
    const [first, second] = meta.map((m) => {
      const p2 = [p[0], p[1]];
      p2.meta = m;
      return p2;
    });
    const firstCurveIndex = first.meta.curveIndex;
    const secondCurveIndex = second.meta.curveIndex;
    const nextCurveIndex = convexHull[(i + 1) % convexHull.length].meta.curveIndex;
    const previousCurveIndex = convexHull[(i - 1 + convexHull.length) % convexHull.length].meta.curveIndex;
    if (firstCurveIndex === nextCurveIndex && secondCurveIndex === previousCurveIndex) {
      return [second, first];
    }
    return [first, second];
  });
  let curveChanges = zipWithNext(convexHull).filter(([p1, p2]) => {
    if (p1.meta.curveIndex === p2.meta.curveIndex) {
      if (p1.meta.curve.geomType === "LINE") {
        return false;
      }
      return Math.abs(p2.meta.pointIndex - p1.meta.pointIndex) !== 1;
    }
    return true;
  }).flat();
  curveChanges = curveChanges.filter((current, i) => {
    const previous = curveChanges[(i + 1) % curveChanges.length];
    const sameCurve = current.meta.curveIndex === previous.meta.curveIndex;
    const samePoint = current.meta.pointIndex === previous.meta.pointIndex;
    return !sameCurve || !samePoint;
  });
  const shape = zipWithNext(curveChanges).filter(([p1, p2]) => !isSamePoint(p1, p2)).map(([p1, p2]) => {
    if (p1.meta.curveIndex === p2.meta.curveIndex) {
      if (p1.meta.pointIndex === 0 && p2.meta.pointIndex === nPoints - 1) {
        return p1.meta.curve;
      }
      if (p1.meta.pointIndex === nPoints - 1 && p2.meta.pointIndex === 0) {
        let c = p1.meta.curve.clone();
        c.reverse();
        return c;
      }
      const splitAt = [p1, p2].filter(
        (p) => p.meta.pointIndex !== 0 && p.meta.pointIndex !== nPoints - 1
      ).map((p) => p.meta.param);
      const segments = p1.meta.curve.splitAt(splitAt);
      let segment = segments[0];
      if (p1.meta.pointIndex !== 0 && p2.meta.pointIndex !== 0) {
        segment = segments[1];
      }
      if (p1.meta.pointIndex > p2.meta.pointIndex) {
        segment.reverse();
      }
      return segment;
    }
    return makeSegmentCurve(p1, p2);
  });
  return new Drawing(new Blueprint(shape));
}

export {
  shrinkWrap
};
//# sourceMappingURL=chunk-XSA22B7J.js.map
