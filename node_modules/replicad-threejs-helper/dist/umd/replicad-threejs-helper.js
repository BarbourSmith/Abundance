(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) :
  typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.replicad = {}, global.three));
})(this, (function (exports, three) { 'use strict';

  /**
   * Create or update a set of threejs geometries from some meshed edges and
   * faces from replicad
   */
  function syncGeometries(replicadMeshes, inputGeometries = []) {
      let geometries = inputGeometries;
      if (inputGeometries.length !== replicadMeshes.length) {
          inputGeometries.forEach(({ lines, faces }) => {
              faces.dispose();
              lines.dispose();
          });
          geometries = replicadMeshes.map(({ name }) => ({
              name,
              faces: new three.BufferGeometry(),
              lines: new three.BufferGeometry(),
          }));
      }
      geometries.forEach(({ faces, lines }, i) => {
          syncFaces(faces, replicadMeshes[i].faces);
          const edges = replicadMeshes[i].edges;
          edges !== undefined
              ? syncLines(lines, edges)
              : syncLinesFromFaces(lines, faces);
      });
      return geometries;
  }
  /**
   * Update a threejs BufferGeometry from some meshed faces from replicad.
   */
  function syncFaces(faces, replicadMesh, highlight) {
      faces.clearGroups();
      delete faces.userData.faceGroups;
      faces.setIndex(replicadMesh.triangles);
      faces.setAttribute("position", new three.Float32BufferAttribute(replicadMesh.vertices, 3));
      // If you want to change the way colors are applied to different faces you
      // can change the following code. The group id will correspond to the index
      // of the materials you link to the mesh of this geometry
      //
      // This only works with two materials, the standard one, and the highlight
      // one.
      if (replicadMesh.faceGroups) {
          let shouldHighlight = new Set();
          if (highlight) {
              shouldHighlight = new Set(highlight);
          }
          faces.userData.faceGroups = replicadMesh.faceGroups;
          replicadMesh.faceGroups.forEach(({ start, count, faceId }) => {
              faces.addGroup(start, count, shouldHighlight.has(faceId) ? 1 : 0);
          });
      }
      else {
          faces.addGroup(0, replicadMesh.triangles.length, 0);
      }
      if (replicadMesh.normals && replicadMesh.normals.length) {
          faces.setAttribute("normal", new three.Float32BufferAttribute(replicadMesh.normals, 3));
      }
      else {
          faces.computeVertexNormals();
      }
      faces.computeBoundingBox();
  }
  /**
   * Update a threejs BufferGeometry from meshed edges from replicad.
   */
  function syncLines(lines, edges, highlight) {
      lines.clearGroups();
      delete lines.userData.edgeGroups;
      lines.setAttribute("position", new three.Float32BufferAttribute(edges.lines, 3));
      if (!edges)
          return;
      if (edges.edgeGroups) {
          let shouldHighlight = new Set();
          if (highlight) {
              shouldHighlight = new Set(highlight);
          }
          lines.userData.edgeGroups = edges.edgeGroups;
          edges.edgeGroups.forEach(({ start, count, edgeId }) => {
              lines.addGroup(start, count, shouldHighlight.has(edgeId) ? 1 : 0);
          });
      }
      else {
          lines.addGroup(0, edges.lines.length / 3, 0);
      }
  }
  /**
   * Update a threejs BufferGeometry from the faces buffer geometry
   * Uses threejs EdgesGeometry to guess the relevant edges
   */
  function syncLinesFromFaces(lines, faces) {
      lines.clearGroups();
      delete lines.userData.edgeGroups;
      lines.copy(new three.EdgesGeometry(faces, 2));
  }
  // Finds the group a specific element is part of
  // This makes the link between the triangles / lines that respectively build
  // faces / edges
  const groupFinder = (faceIndex) => ({ start, count }) => {
      return faceIndex >= start && faceIndex < start + count;
  };
  /**
   * Changes the material used to represent a certain face or edge by the index
   * of its group
   */
  function toggleHighlight(groupIndex, geometry) {
      const group = geometry.groups.find(groupFinder(groupIndex));
      if (group) {
          group.materialIndex = group.materialIndex ? 0 : 1;
          // @ts-expect-error types not up to date
          geometry.groupsNeedUpdate = true;
      }
  }
  /**
   * Set all the materials used to the default one.
   */
  function clearHighlights(geometry) {
      geometry.groups.forEach((g) => {
          if (g.materialIndex !== 0) {
              // @ts-expect-error types not up to date
              geometry.groupsNeedUpdate = true;
              g.materialIndex = 0;
          }
      });
  }
  /**
   * Make sure that the elements highlighted in the geometry are only the ones in
   * the elements param.
   */
  function highlightInGeometry(elements, geometry) {
      const groupIndices = new Set(elements);
      // @ts-expect-error types not up to date
      geometry.groups.forEach((group, groupIndex) => {
          const shouldHighlight = groupIndices.has(groupIndex);
          const isHighlighted = group.materialIndex === 1;
          if (shouldHighlight === isHighlighted)
              return;
          group.materialIndex = shouldHighlight ? 1 : 0;
          // @ts-expect-error types not up to date
          geometry.groupsNeedUpdate = true;
      });
  }
  function getFaceId(triangleIndex, geometry) {
      const { faceId } = geometry.userData.faceGroups.find(groupFinder(triangleIndex * 3)) || {};
      return faceId;
  }
  function getEdgeId(lineIndex, geometry) {
      const { edgeId } = geometry.userData.edgeGroups.find(groupFinder(lineIndex)) || {};
      return edgeId;
  }
  function getFaceIndex(triangleIndex, geometry) {
      return geometry.groups.findIndex(groupFinder(triangleIndex * 3));
  }
  function getEdgeIndex(lineIndex, geometry) {
      return geometry.groups.findIndex(groupFinder(lineIndex));
  }

  exports.clearHighlights = clearHighlights;
  exports.getEdgeId = getEdgeId;
  exports.getEdgeIndex = getEdgeIndex;
  exports.getFaceId = getFaceId;
  exports.getFaceIndex = getFaceIndex;
  exports.highlightInGeometry = highlightInGeometry;
  exports.syncFaces = syncFaces;
  exports.syncGeometries = syncGeometries;
  exports.syncLines = syncLines;
  exports.syncLinesFromFaces = syncLinesFromFaces;
  exports.toggleHighlight = toggleHighlight;

}));
//# sourceMappingURL=replicad-threejs-helper.js.map
